#pragma once

#include <Grid/Grid.h>
#include <algorithm>
#include <random>


using namespace std;
using namespace Grid;


std::string basedir="/usr/workspace/lsd/matsumoto5/su4_dane_analysis/reweight/data/16c/";
Real mass=0.4;
std::vector<Real> betas({11.01, 11.02, 11.03, 11.04, 11.05, 11.06, 11.07, 11.08, 11.09});
std::string obsinfo="polyakov";


class EnsembleOfObs : public Serializable {
public:
  GRID_SERIALIZABLE_CLASS_MEMBERS(
                                  EnsembleOfObs,
                                  Real, beta,
                                  //
                                  int, conf_min,
                                  int, conf_max,
                                  int, interval,
                                  //
                                  std::string, base_dir,
                                  std::string, id,
                                  //
                                  std::vector<RealD>, energies,
                                  std::vector<RealD>, Os,
                                  std::vector<RealD>, Osqs
                                  );

  int size() const {
    // return (conf_max-conf_min)/interval;
    assert( energies.size()==Os.size() );
    return energies.size();
  }
};


// Geoge's email on 2/18/2025
class FreeEnergies : public Serializable {
public:
  GRID_SERIALIZABLE_CLASS_MEMBERS(
                                  FreeEnergies,
                                  std::vector<RealD>, f
                                  );
  std::vector<RealD> fnew;
  std::vector<RealD> fold;

  const int nparam;

  FreeEnergies(const int nparam)
    : nparam(nparam)
    , f(nparam, 0.0)
    , fnew(nparam, 0.0)
    , fold(nparam, 0.0)
  {}

  // @@@ TODO: fwrite, fread, forecasting

  void recenter_fnew(){
    const RealD fmin = *std::min_element(fnew.begin(), fnew.end());
    const RealD fmax = *std::max_element(fnew.begin(), fnew.end());
    for(RealD& elem : fnew) elem = elem - 0.5 * (fmin + fmax) ;
  }

  void update(){
    for (int j=0; j<nparam; j++) {
      f[j]    = fnew[j] ;
      fold[j] = fnew[j] ;
    }
  }

  RealD operator[](const int i) const { return f[i]; }
  RealD o(const int i) const { return fold[i]; }
  RealD n(const int i) const { return fnew[i]; }

  RealD& operator[](const int i) { return f[i]; }
  RealD& o(const int i) { return fold[i]; }
  RealD& n(const int i) { return fnew[i]; }

  RealD diff_norm_sq() const {
    double res = 0.0;
    for(int i=0; i<nparam; i++) res += (fold[i]-fnew[i])*(fold[i]-fnew[i]);
    return res;
  }

  RealD norm_sq() const {
    double res = 0.0;
    for(int i=0; i<nparam; i++) res += fold[i]*fold[i];
    return res;
  }
};



// lse_max from George
RealD lse_max(const std::vector<RealD>& a) {
  const RealD max = *std::max_element(a.begin(), a.end());
  RealD sum = 0.0;
  for(const RealD& elem : a) sum += std::exp( elem - max );
  return max + std::log(sum);
}


// RealD lse_max(const std::vector<std::vector<RealD>>& a) {
//   std::vector<RealD> tmp;
//   for(auto& v : a) tmp.push_back( lse_max(v) );
//   return lse_max(tmp);
// }



class LogRs {
public:
  std::vector<RealD> logRs;

  // reweighting betas
  Real beta_i;
  Real beta_j;
  Real beta_k;

  LogRs(){}

  void set(const Real beta_i_,
           const Real beta_j_,
           const Real beta_k_,
           const std::vector<RealD>& energies_k){
    beta_i = beta_i_;
    beta_j = beta_j_;
    beta_k = beta_k_;

    for(const RealD& H : energies_k){
      logRs.push_back( -(beta_j-beta_i)*H );
    }
  }

  RealD operator[](const int i) const { return logRs[i]; }
  int size() const { return logRs.size(); } // Nk
};



class LogGs {
public:
  std::vector<RealD> logGs;
  std::vector<RealD> logGPs;

  Real beta_i;
  Real beta_k;
  int size; // sample size of ensemble k
  int nparam;

  LogGs(){};

  LogGs(const std::vector<LogRs>& vj_logRs, const FreeEnergies& fs, const std::vector<Real>& logNs){
    set(vj_logRs, fs, logNs);
  }

  void set( const std::vector<LogRs>& vj_logRs, const FreeEnergies& fs, const std::vector<Real>& logNs ){
    beta_i = vj_logRs[0].beta_i;
    beta_k = vj_logRs[0].beta_k;

    size = vj_logRs[0].size();
    nparam = vj_logRs.size();

    for(const LogRs& logRs : vj_logRs) {
      assert( std::abs(logRs.beta_i-beta_i)<1.0e-14 ); // same shift
      assert( std::abs(logRs.beta_k-beta_k)<1.0e-14 ); // same ensemble
      assert( size==logRs.size() ); // same size
    }
    assert(fs.nparam==nparam); // same nparam
    assert(logNs.size()==nparam); // same nparam

    for(int ik=0; ik<size; ik++) {
      std::vector<RealD> b(fs.nparam);
      for(int j=0; j<nparam; j++) {
        b[j] = logNs[j] + fs[j] + vj_logRs[j][ik];
      }
      logGs.push_back( -lse_max(b) );
    }
  }

  void add_logGPs( const std::vector<RealD>& Os ){
    assert( size>0 );
    logGPs.resize( size );

    for(int ik=0; ik<size; ik++) {
      assert( Os[ik]>0.0);
      logGPs[ik] = std::log( Os[ik] ) + logGs[ik];
    }
  }

  RealD operator[](const int i) const { return logGs[i]; }

  RealD get_B() const {
    return lse_max( logGs );
  }
  RealD get_BP() const {
    return lse_max( logGPs );
  }
};







void run_multihistogram( const std::vector<Real>& betas,
                         const std::vector<std::vector<RealD>>& v_energies,
                         FreeEnergies& fs ){
  const int nparam = betas.size();
  assert( fs.nparam==nparam );

  std::vector<Real> logNs( nparam );
  for(int j=0; j<nparam; j++){
    logNs[j] = std::log(v_energies[j].size());
  }

  // -------------------------
  // pre calc
  // -------------------------
  std::vector<std::vector<std::vector<LogRs>>> logRs_ikj;
  // just resizing
  logRs_ikj.resize( nparam );
  for(auto& logRs_kj : logRs_ikj){
    logRs_kj.resize( nparam );
    for(auto& logRs_j : logRs_kj){
      logRs_j.resize( nparam );
    }
  }

#ifdef _OPENMP
#pragma omp parallel for collapse(3)
#endif
  for(int i=0; i<nparam; i++) {
    for(int k=0; k<nparam; k++){
      for(int j=0; j<nparam; j++){
        logRs_ikj[i][k][j].set( betas[i], betas[j], betas[k], v_energies[k] );
      }}}

  std::cout << GridLogMessage << "logR set" << std::endl;

  // -------------------------
  // main loop
  // -------------------------

  do{
    fs.update();

    std::vector<std::vector<RealD>> B_ik(nparam, std::vector<RealD>(nparam));
#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
    for(int i=0; i<nparam; i++) {
      for(int k=0; k<nparam; k++) {
        const LogGs logGs( logRs_ikj[i][k], fs, logNs );
        B_ik[i][k] = logGs.get_B();
      }
    }

#ifdef _OPENMP
#pragma omp parallel for
#endif
    for(int i=0; i<nparam; i++) {
      fs.n(i) = - lse_max( B_ik[i] );
    }

    fs.recenter_fnew();
    // @@@ TODO:forecasting

    std::cout << GridLogMessage << "norm = " << fs.diff_norm_sq() << std::endl;
  } while( fs.diff_norm_sq() > 1.0e-17 * fs.norm_sq() );

}





class ReweightedObs : public Serializable {
  const Real beta_min;
  const Real beta_max;

public:
  const int nmeas;
  const int nparam;

  std::vector<std::vector<RealD>> v_energies;
  std::vector<std::vector<RealD>> v_Os;
  std::vector<std::vector<RealD>> v_Osqs;
  std::vector<Real> logNs;

  GRID_SERIALIZABLE_CLASS_MEMBERS(
                                  ReweightedObs,
                                  //
                                  std::vector<Real>, betas,
                                  std::vector<RealD>, fs,
                                  std::vector<RealD>, fPs,
                                  std::vector<RealD>, fPs_sq
                                  );

  ReweightedObs( const Real beta_min_,
                 const Real beta_max_,
                 const int nmeas_,
                 const std::vector<EnsembleOfObs> ensembles
                 )
    : beta_min(beta_min_)
    , beta_max(beta_max_)
    , nmeas(nmeas_)
    , nparam(ensembles.size())
    , v_energies(nparam)
    , v_Os(nparam)
    , v_Osqs(nparam)
    , logNs(nparam)
    , betas( nmeas+1 )
    , fs( nmeas+1 )
    , fPs( nmeas+1 )
    , fPs_sq( nmeas+1 )
  {
    for(int k=0; k<nparam; k++){
      v_energies[k] = ensembles[k].energies;
      v_Os[k] = ensembles[k].Os;
      v_Osqs[k] = ensembles[k].Osqs;
      logNs[k] = std::log(v_energies[k].size());
    }
    for(int i=0; i<=nmeas; i++) betas[i] = beta_min + i*(beta_max-beta_min)/nmeas;
  }

  RealD est( const int i ) const {
    assert( i<=nmeas );
    return std::exp( fs[i] - fPs[i] );
  }

  RealD est_sq( const int i ) const {
    assert( i<=nmeas );
    return std::exp( fs[i] - fPs_sq[i] );
  }
};





void run_reweighting( const std::vector<Real>& betas,
                      const std::vector<EnsembleOfObs>& ensembles,
                      const FreeEnergies& fs,
                      ReweightedObs& meas ){
  const int nparam=meas.nparam;
  const int nmeas=meas.nmeas;

  std::vector<std::vector<std::vector<LogRs>>> logRs_ikj;
  logRs_ikj.resize( nmeas+1 );
  for(auto& logRs_kj : logRs_ikj){
    logRs_kj.resize( nparam );
    for(auto& logRs_j : logRs_kj){
      logRs_j.resize( nparam );
    }
  }

#ifdef _OPENMP
#pragma omp parallel for collapse(3)
#endif
  for(int i=0; i<=nmeas; i++) {
    for(int k=0; k<nparam; k++){
      for(int j=0; j<nparam; j++){
        logRs_ikj[i][k][j].set( meas.betas[i], betas[j], betas[k], meas.v_energies[k] );
      }}}

  std::cout << GridLogMessage << "logR set" << std::endl;


  // =================================


  std::vector<std::vector<LogGs>> logGs_ik( nmeas+1, std::vector<LogGs>(nparam) );
#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
  for(int i=0; i<=nmeas; i++) {
    for(int k=0; k<nparam; k++) {
      logGs_ik[i][k].set( logRs_ikj[i][k], fs, meas.logNs );
    }
  }

  std::cout << GridLogMessage << "logGs set" << std::endl;

  std::vector<std::vector<RealD>> Bs_ik(nmeas+1, std::vector<RealD>(nparam) );
#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
  for(int i=0; i<=nmeas; i++){
    for(int k=0; k<nparam; k++) Bs_ik[i][k] = logGs_ik[i][k].get_B();
  }

  std::cout << GridLogMessage << "Bs set" << std::endl;


#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(int i=0; i<=nmeas; i++){
    meas.fs[i] = -lse_max( Bs_ik[i] );
  }


  std::vector<std::vector<RealD>> BPs_ik( nmeas+1, std::vector<RealD>(nparam) );
#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
  for(int i=0; i<=nmeas; i++) {
    for(int k=0; k<nparam; k++){
      logGs_ik[i][k].add_logGPs( meas.v_Os[k] );
      BPs_ik[i][k] = logGs_ik[i][k].get_BP();
    }
  }

  std::vector<std::vector<RealD>> BPs_sq_ik( nmeas+1, std::vector<RealD>(nparam) );
#ifdef _OPENMP
#pragma omp parallel for collapse(2)
#endif
  for(int i=0; i<=nmeas; i++) {
    for(int k=0; k<nparam; k++){
      logGs_ik[i][k].add_logGPs( meas.v_Osqs[k] );
      BPs_sq_ik[i][k] = logGs_ik[i][k].get_BP();
    }
  }


#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(int i=0; i<=nmeas; i++) {
    meas.fPs[i] = -lse_max( BPs_ik[i] );
  }

#ifdef _OPENMP
#pragma omp parallel for
#endif
  for(int i=0; i<=nmeas; i++) {
    meas.fPs_sq[i] = -lse_max( BPs_sq_ik[i] );
  }

}







